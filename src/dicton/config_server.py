"""Configuration web UI server for Dicton."""

import base64
import json
import webbrowser
from pathlib import Path
from threading import Timer
from typing import Any

from .config import Config, config


def _load_logo_base64() -> str:
    """Load logo from package assets folder and convert to base64."""
    logo_path = Path(__file__).parent / "assets" / "logo.png"
    if logo_path.exists():
        return base64.b64encode(logo_path.read_bytes()).decode("utf-8")
    return ""


LOGO_BASE64 = _load_logo_base64()


def _load_html_template() -> str:
    """Load HTML template for the configuration UI."""
    template_path = Path(__file__).parent / "assets" / "config_ui.html"
    if template_path.exists():
        html = template_path.read_text(encoding="utf-8")
        return html.replace("{{LOGO_BASE64}}", LOGO_BASE64)
    return "<html><body>Config UI template missing.</body></html>"


# HTML template with dashboard
HTML_TEMPLATE = _load_html_template()


def get_env_path() -> Path:
    """Get the .env file path for writing (always user config dir)."""
    return Config.CONFIG_DIR / ".env"


def _find_env_file() -> Path | None:
    """Find .env file - prioritize user config over system config."""
    locations = [
        Config.CONFIG_DIR / ".env",  # User config dir (~/.config/dicton/) - FIRST!
        Path.cwd() / ".env",  # Current working directory
        Path("/opt/dicton/.env"),  # System install (read-only fallback)
    ]
    for env_path in locations:
        if env_path.exists():
            return env_path
    return None


def read_env_file() -> dict[str, str]:
    """Read the .env file and return as dict (checks multiple locations)."""
    env_path = _find_env_file()
    if env_path is None:
        return {}

    env_vars: dict[str, str] = {}
    with open(env_path, encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            if "=" in line:
                key, _, value = line.partition("=")
                # Strip quotes from value
                value = value.strip().strip("\"'")
                env_vars[key.strip()] = value

    return env_vars


def write_env_file(env_vars: dict[str, str]) -> None:
    """Write env vars to .env file."""
    env_path = get_env_path()
    env_path.parent.mkdir(parents=True, exist_ok=True)

    lines = ["# Dicton configuration", "# Generated by dicton --config-ui", ""]

    for key, value in sorted(env_vars.items()):
        # Quote values with spaces
        if " " in value or not value:
            value = f'"{value}"'
        lines.append(f"{key}={value}")

    with open(env_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines) + "\n")


def _mask_api_key(key: str) -> str:
    """Mask API key showing first char + dots + last 2 chars."""
    if not key or len(key) < 4:
        return ""
    return f"{key[0]}{'•' * 8}{key[-2:]}"


def get_current_config() -> dict[str, Any]:
    """Get current configuration as dict."""
    env_vars = read_env_file()

    # Get API keys with masking
    mistral_key = env_vars.get("MISTRAL_API_KEY", "")
    elevenlabs_key = env_vars.get("ELEVENLABS_API_KEY", "")
    gemini_key = env_vars.get("GEMINI_API_KEY", "")
    anthropic_key = env_vars.get("ANTHROPIC_API_KEY", "")

    return {
        # STT settings
        "stt_provider": env_vars.get("STT_PROVIDER", config.STT_PROVIDER),
        # API keys - masked values for display
        "mistral_api_key_set": bool(mistral_key),
        "mistral_api_key_masked": _mask_api_key(mistral_key),
        "elevenlabs_api_key_set": bool(elevenlabs_key),
        "elevenlabs_api_key_masked": _mask_api_key(elevenlabs_key),
        "gemini_api_key_set": bool(gemini_key),
        "gemini_api_key_masked": _mask_api_key(gemini_key),
        "anthropic_api_key_set": bool(anthropic_key),
        "anthropic_api_key_masked": _mask_api_key(anthropic_key),
        # Other config values
        "llm_provider": env_vars.get("LLM_PROVIDER", config.LLM_PROVIDER),
        "theme_color": env_vars.get("THEME_COLOR", config.THEME_COLOR),
        "visualizer_style": env_vars.get("VISUALIZER_STYLE", config.VISUALIZER_STYLE),
        "animation_position": env_vars.get("ANIMATION_POSITION", config.ANIMATION_POSITION),
        "visualizer_backend": env_vars.get("VISUALIZER_BACKEND", config.VISUALIZER_BACKEND),
        "hotkey_base": env_vars.get("HOTKEY_BASE", config.HOTKEY_BASE),
        "hotkey_hold_threshold_ms": env_vars.get(
            "HOTKEY_HOLD_THRESHOLD_MS", str(config.HOTKEY_HOLD_THRESHOLD_MS)
        ),
        "hotkey_double_tap_window_ms": env_vars.get(
            "HOTKEY_DOUBLE_TAP_WINDOW_MS", str(config.HOTKEY_DOUBLE_TAP_WINDOW_MS)
        ),
        "filter_fillers": env_vars.get("FILTER_FILLERS", "true").lower() == "true",
        "enable_reformulation": env_vars.get("ENABLE_REFORMULATION", "true").lower() == "true",
        "language": env_vars.get("LANGUAGE", config.LANGUAGE),
        "debug": env_vars.get("DEBUG", "false").lower() == "true",
        # Hotkey settings
        "custom_hotkey_value": env_vars.get("CUSTOM_HOTKEY_VALUE", "alt+g"),
        "secondary_hotkey": env_vars.get("SECONDARY_HOTKEY", "none"),
        "secondary_hotkey_translation": env_vars.get("SECONDARY_HOTKEY_TRANSLATION", "none"),
        "secondary_hotkey_act_on_text": env_vars.get("SECONDARY_HOTKEY_ACT_ON_TEXT", "none"),
        # Context detection settings
        "context_enabled": env_vars.get("CONTEXT_ENABLED", "true").lower() == "true",
        "context_debug": env_vars.get("CONTEXT_DEBUG", "false").lower() == "true",
        "mute_playback_on_recording": (
            env_vars.get("MUTE_PLAYBACK_ON_RECORDING", "true").lower() == "true"
        ),
        "mute_mic_on_recording": env_vars.get("MUTE_MIC_ON_RECORDING", "true").lower() == "true",
        "playback_mute_strategy": env_vars.get(
            "PLAYBACK_MUTE_STRATEGY", config.PLAYBACK_MUTE_STRATEGY
        ),
        "mute_backend": env_vars.get("MUTE_BACKEND", config.MUTE_BACKEND),
    }


def save_config(data: dict[str, Any]) -> None:
    """Save configuration to .env file."""
    env_vars = read_env_file()

    # Map UI fields to env vars
    field_map = {
        "stt_provider": "STT_PROVIDER",
        "mistral_api_key": "MISTRAL_API_KEY",
        "elevenlabs_api_key": "ELEVENLABS_API_KEY",
        "gemini_api_key": "GEMINI_API_KEY",
        "anthropic_api_key": "ANTHROPIC_API_KEY",
        "llm_provider": "LLM_PROVIDER",
        "theme_color": "THEME_COLOR",
        "visualizer_style": "VISUALIZER_STYLE",
        "animation_position": "ANIMATION_POSITION",
        "visualizer_backend": "VISUALIZER_BACKEND",
        "hotkey_base": "HOTKEY_BASE",
        "hotkey_hold_threshold_ms": "HOTKEY_HOLD_THRESHOLD_MS",
        "hotkey_double_tap_window_ms": "HOTKEY_DOUBLE_TAP_WINDOW_MS",
        "filter_fillers": "FILTER_FILLERS",
        "enable_reformulation": "ENABLE_REFORMULATION",
        "language": "LANGUAGE",
        "debug": "DEBUG",
        "custom_hotkey_value": "CUSTOM_HOTKEY_VALUE",
        "secondary_hotkey": "SECONDARY_HOTKEY",
        "secondary_hotkey_translation": "SECONDARY_HOTKEY_TRANSLATION",
        "secondary_hotkey_act_on_text": "SECONDARY_HOTKEY_ACT_ON_TEXT",
        "context_enabled": "CONTEXT_ENABLED",
        "context_debug": "CONTEXT_DEBUG",
        "mute_playback_on_recording": "MUTE_PLAYBACK_ON_RECORDING",
        "mute_mic_on_recording": "MUTE_MIC_ON_RECORDING",
        "playback_mute_strategy": "PLAYBACK_MUTE_STRATEGY",
        "mute_backend": "MUTE_BACKEND",
    }

    for ui_field, env_var in field_map.items():
        if ui_field in data:
            value = data[ui_field]
            if isinstance(value, bool):
                value = "true" if value else "false"
            env_vars[env_var] = str(value)

    write_env_file(env_vars)


def get_dictionary() -> dict[str, Any]:
    """Get dictionary contents."""
    dictionary_path = Config.CONFIG_DIR / "dictionary.json"
    if not dictionary_path.exists():
        return {"similarity_words": [], "replacements": {}, "case_sensitive": {}, "patterns": []}

    try:
        with open(dictionary_path, encoding="utf-8") as f:
            data = json.load(f)
            # Ensure similarity_words exists
            if "similarity_words" not in data:
                data["similarity_words"] = []
            return data
    except (json.JSONDecodeError, OSError):
        return {"similarity_words": [], "replacements": {}, "case_sensitive": {}, "patterns": []}


def save_dictionary(data: dict[str, Any]) -> None:
    """Save dictionary to file."""
    dictionary_path = Config.CONFIG_DIR / "dictionary.json"
    dictionary_path.parent.mkdir(parents=True, exist_ok=True)

    with open(dictionary_path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)


def add_similarity_word(word: str) -> None:
    """Add a word to the similarity dictionary."""
    data = get_dictionary()
    if "similarity_words" not in data:
        data["similarity_words"] = []
    if word not in data["similarity_words"]:
        data["similarity_words"].append(word)
        save_dictionary(data)


def remove_similarity_word(word: str) -> None:
    """Remove a word from the similarity dictionary."""
    data = get_dictionary()
    if word in data.get("similarity_words", []):
        data["similarity_words"].remove(word)
        save_dictionary(data)


# Test recording state
_test_state = {
    "recording": False,
    "audio_data": None,
    "recognizer": None,
    "record_thread": None,
    "frames": [],
    "stream": None,
    "start_time": None,
}


def _background_record():
    """Background thread function to record audio."""
    import pyaudio

    from .speech_recognition_engine import suppress_stderr

    if _test_state["recognizer"] is None:
        return

    recognizer = _test_state["recognizer"]
    _test_state["frames"] = []

    try:
        with suppress_stderr():
            stream = recognizer.audio.open(
                format=pyaudio.paInt16,
                channels=1,
                rate=config.SAMPLE_RATE,
                input=True,
                input_device_index=recognizer.input_device,
                frames_per_buffer=config.CHUNK_SIZE,
            )
        _test_state["stream"] = stream

        while _test_state["recording"]:
            try:
                data = stream.read(config.CHUNK_SIZE, exception_on_overflow=False)
                _test_state["frames"].append(data)
            except Exception:
                break

    except Exception as e:
        print(f"❌ Background recording error: {e}")

    finally:
        if _test_state["stream"]:
            try:
                _test_state["stream"].stop_stream()
                _test_state["stream"].close()
            except Exception:
                pass
            _test_state["stream"] = None


def create_app():
    """Create FastAPI application."""
    try:
        from fastapi import FastAPI, Request
        from fastapi.responses import HTMLResponse, JSONResponse
        from pydantic import BaseModel
    except ImportError as e:
        raise ImportError(
            "FastAPI not installed. Install with: pip install dicton[configui]"
        ) from e

    app = FastAPI(title="Dicton Dashboard")

    class ConfigData(BaseModel):
        elevenlabs_api_key: str | None = None
        gemini_api_key: str | None = None
        anthropic_api_key: str | None = None
        llm_provider: str | None = None
        theme_color: str | None = None
        visualizer_style: str | None = None
        animation_position: str | None = None
        visualizer_backend: str | None = None
        hotkey_base: str | None = None
        hotkey_hold_threshold_ms: str | None = None
        hotkey_double_tap_window_ms: str | None = None
        filter_fillers: bool | None = None
        enable_reformulation: bool | None = None
        language: str | None = None
        debug: bool | None = None
        custom_hotkey_value: str | None = None
        secondary_hotkey: str | None = None
        secondary_hotkey_translation: str | None = None
        secondary_hotkey_act_on_text: str | None = None
        context_enabled: bool | None = None
        context_debug: bool | None = None
        mute_playback_on_recording: bool | None = None
        mute_mic_on_recording: bool | None = None
        playback_mute_strategy: str | None = None
        mute_backend: str | None = None

    @app.get("/", response_class=HTMLResponse)
    async def root():
        return HTML_TEMPLATE

    @app.get("/api/config")
    async def api_get_config():
        return JSONResponse(get_current_config())

    @app.post("/api/config")
    async def api_save_config(data: ConfigData):
        try:
            config_dict = data.model_dump(exclude_none=True)
            print(f"[DEBUG] Received config data: {config_dict}")
            print(
                f"[DEBUG] Secondary hotkeys: basic={config_dict.get('secondary_hotkey')}, translation={config_dict.get('secondary_hotkey_translation')}, act={config_dict.get('secondary_hotkey_act_on_text')}"
            )
            print(f"[DEBUG] Writing to: {get_env_path()}")
            save_config(config_dict)
            return {"status": "ok"}
        except Exception as e:
            import traceback

            print(f"[ERROR] Save config failed: {e}")
            traceback.print_exc()
            return JSONResponse({"status": "error", "message": str(e)}, status_code=500)

    @app.get("/api/dictionary")
    async def api_get_dictionary():
        return JSONResponse(get_dictionary())

    @app.post("/api/dictionary")
    async def api_add_similarity_word(data: dict):
        word = data.get("word", "")
        if word:
            add_similarity_word(word)
            return {"status": "ok"}
        return JSONResponse({"error": "Missing word"}, status_code=400)

    @app.delete("/api/dictionary")
    async def api_remove_similarity_word(data: dict):
        word = data.get("word", "")
        if word:
            remove_similarity_word(word)
            return {"status": "ok"}
        return JSONResponse({"error": "Missing word"}, status_code=400)

    @app.get("/api/context/profiles")
    async def api_get_context_profiles():
        """Get list of available context profiles."""
        try:
            from .context_profiles import get_profile_manager

            manager = get_profile_manager()
            manager.load()
            return list(manager.list_profiles())
        except Exception as e:
            return JSONResponse({"error": str(e)}, status_code=500)

    @app.get("/api/context/current")
    async def api_get_current_context():
        """Get current context detection result."""
        try:
            from .context_detector import get_context_detector
            from .context_profiles import get_profile_manager

            detector = get_context_detector()
            if not detector:
                return {
                    "app_name": "N/A",
                    "window_title": "Context detection not available",
                    "wm_class": "",
                    "matched_profile": "default",
                    "typing_speed": "normal",
                }

            context = detector.get_context()
            manager = get_profile_manager()
            profile = manager.match_context(context)

            return {
                "app_name": context.app_name if context else "",
                "window_title": context.window.title if context and context.window else "",
                "wm_class": context.window.wm_class if context and context.window else "",
                "matched_profile": profile.name if profile else "default",
                "typing_speed": profile.typing_speed if profile else "normal",
            }
        except Exception as e:
            return JSONResponse({"error": str(e)}, status_code=500)

    @app.get("/api/context/profiles/{profile_name}")
    async def api_get_profile(profile_name: str):
        """Get a specific profile's full details."""
        try:
            from .context_profiles import get_profile_manager

            manager = get_profile_manager()
            manager.load()
            profile = manager.get_profile(profile_name)

            if not profile:
                return JSONResponse(
                    {"error": f"Profile '{profile_name}' not found"}, status_code=404
                )

            return {
                "name": profile.name,
                "match": {
                    "wm_class": profile.match.wm_class,
                    "window_title_contains": profile.match.window_title_contains,
                    "file_extension": profile.match.file_extension,
                    "widget_role": profile.match.widget_role,
                    "url_contains": profile.match.url_contains,
                },
                "llm_preamble": profile.llm_preamble,
                "typing_speed": profile.typing_speed,
                "formatting": profile.formatting,
                "extends": profile.extends,
                "priority": profile.priority,
            }
        except Exception as e:
            return JSONResponse({"error": str(e)}, status_code=500)

    @app.put("/api/context/profiles/{profile_name}")
    async def api_update_profile(profile_name: str, request: Request):
        """Update or create a profile (saved to user config)."""
        import json
        from pathlib import Path

        try:
            data = await request.json()
            user_config_path = Path.home() / ".config" / "dicton" / "contexts.json"

            # Load existing user config or start fresh
            if user_config_path.exists():
                with open(user_config_path) as f:
                    user_config = json.load(f)
            else:
                user_config = {"profiles": {}, "typing_speeds": {}}

            # Update/add the profile
            user_config["profiles"][profile_name] = {
                "match": data.get("match", {}),
                "llm_preamble": data.get("llm_preamble", ""),
                "typing_speed": data.get("typing_speed", "normal"),
                "formatting": data.get("formatting", "auto"),
                "priority": data.get("priority", 0),
            }

            if data.get("extends"):
                user_config["profiles"][profile_name]["extends"] = data["extends"]

            # Ensure config directory exists
            user_config_path.parent.mkdir(parents=True, exist_ok=True)

            # Write to user config
            with open(user_config_path, "w") as f:
                json.dump(user_config, f, indent=2)

            # Reload profiles
            from .context_profiles import get_profile_manager

            manager = get_profile_manager()
            manager.reload()

            return {"status": "ok", "profile": profile_name}
        except Exception as e:
            return JSONResponse({"error": str(e)}, status_code=500)

    @app.delete("/api/context/profiles/{profile_name}")
    async def api_delete_profile(profile_name: str):
        """Delete a user profile (cannot delete bundled defaults)."""
        import json
        from pathlib import Path

        try:
            if profile_name == "default":
                return JSONResponse({"error": "Cannot delete the default profile"}, status_code=400)

            user_config_path = Path.home() / ".config" / "dicton" / "contexts.json"

            if not user_config_path.exists():
                return JSONResponse(
                    {
                        "error": f"Profile '{profile_name}' is a bundled default and cannot be deleted"
                    },
                    status_code=400,
                )

            with open(user_config_path) as f:
                user_config = json.load(f)

            if profile_name not in user_config.get("profiles", {}):
                return JSONResponse(
                    {
                        "error": f"Profile '{profile_name}' is a bundled default and cannot be deleted"
                    },
                    status_code=400,
                )

            # Remove from user config
            del user_config["profiles"][profile_name]

            with open(user_config_path, "w") as f:
                json.dump(user_config, f, indent=2)

            # Reload profiles
            from .context_profiles import get_profile_manager

            manager = get_profile_manager()
            manager.reload()

            return {"status": "ok", "deleted": profile_name}
        except Exception as e:
            return JSONResponse({"error": str(e)}, status_code=500)

    @app.post("/api/test/start")
    async def api_test_start():
        """Start recording for latency test."""
        import threading
        import time

        from .speech_recognition_engine import SpeechRecognizer

        # Clean up any previous test state
        if _test_state["recording"]:
            _test_state["recording"] = False
            if _test_state["record_thread"]:
                _test_state["record_thread"].join(timeout=1.0)

        # Initialize recognizer
        _test_state["recognizer"] = SpeechRecognizer()
        _test_state["frames"] = []
        _test_state["audio_data"] = None
        _test_state["start_time"] = time.time()
        _test_state["recording"] = True

        # Start background recording thread
        _test_state["record_thread"] = threading.Thread(target=_background_record)
        _test_state["record_thread"].start()

        return {"status": "recording"}

    @app.post("/api/test/stop")
    async def api_test_stop():
        """Stop recording and run transcription test - mirrors exact production flow."""
        import time

        import numpy as np

        if not _test_state["recording"]:
            return JSONResponse({"error": "Not recording"}, status_code=400)

        # Stop recording
        _test_state["recording"] = False
        record_end_time = time.time()
        record_duration_ms = (record_end_time - _test_state["start_time"]) * 1000

        # Wait for recording thread to finish
        if _test_state["record_thread"]:
            _test_state["record_thread"].join(timeout=2.0)

        # Convert captured frames to audio array
        frames = _test_state["frames"]
        if not frames:
            return JSONResponse({"error": "No audio captured"}, status_code=400)

        audio_data = b"".join(frames)
        audio_array = np.frombuffer(audio_data, dtype=np.int16).astype(np.float32) / 32768.0

        # Get the recognizer used for recording (same instance for transcription)
        recognizer = _test_state["recognizer"]
        if not recognizer:
            return JSONResponse({"error": "Recognizer not available"}, status_code=500)

        result = {
            "latency": {
                "recording": record_duration_ms,
                "stt": 0,
                "llm": 0,
                "total": 0,
            },
            "text": "",
            "stt_provider": "ElevenLabs" if recognizer.use_elevenlabs else "None",
        }

        try:
            # === STEP 1: STT Transcription (mirrors production) ===
            stt_start = time.time()
            text = recognizer.transcribe(audio_array)
            result["latency"]["stt"] = (time.time() - stt_start) * 1000

            if not text:
                result["error"] = "No speech detected"
                return JSONResponse(result)

            # === STEP 2: LLM Processing (mirrors production _process_text for BASIC mode) ===
            llm_start = time.time()
            try:
                from . import llm_processor

                if config.ENABLE_REFORMULATION and llm_processor.is_available():
                    processed = llm_processor.reformulate(text)
                    if processed:
                        text = processed
                    result["llm_provider"] = config.LLM_PROVIDER.capitalize()
                else:
                    result["llm_provider"] = (
                        "Disabled" if not config.ENABLE_REFORMULATION else "Not configured"
                    )
            except ImportError:
                result["llm_provider"] = "Not available"

            result["latency"]["llm"] = (time.time() - llm_start) * 1000

            result["text"] = text
            result["latency"]["total"] = (
                result["latency"]["recording"] + result["latency"]["stt"] + result["latency"]["llm"]
            )

        except Exception as e:
            result["error"] = str(e)

        finally:
            # Cleanup
            if _test_state["recognizer"]:
                _test_state["recognizer"].cleanup()
                _test_state["recognizer"] = None
            _test_state["frames"] = []

        return JSONResponse(result)

    return app


def find_available_port(start_port: int = 6873, max_attempts: int = 10) -> int:
    """Find an available port starting from start_port."""
    import socket

    for offset in range(max_attempts):
        port = start_port + offset
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.bind(("127.0.0.1", port))
                return port
        except OSError:
            continue

    raise RuntimeError(
        f"Could not find available port in range {start_port}-{start_port + max_attempts}"
    )


def run_config_server(port: int = 6873, open_browser: bool = True) -> None:
    """Run the configuration server."""
    try:
        import uvicorn
    except ImportError:
        print("Error: FastAPI/uvicorn not installed.")
        print("Install with: pip install dicton[configui]")
        return

    # Find available port if requested port is in use
    try:
        actual_port = find_available_port(port)
        if actual_port != port:
            print(f"Port {port} in use, using {actual_port}")
    except RuntimeError as e:
        print(f"Error: {e}")
        return

    app = create_app()

    print(f"\n{'=' * 50}")
    print("Dicton Dashboard")
    print(f"{'=' * 50}")
    print(f"Open: http://localhost:{actual_port}")
    print("Press Ctrl+C to stop")
    print(f"{'=' * 50}\n")

    if open_browser:
        Timer(1.0, lambda: webbrowser.open(f"http://localhost:{actual_port}")).start()

    uvicorn.run(app, host="127.0.0.1", port=actual_port, log_level="warning")
